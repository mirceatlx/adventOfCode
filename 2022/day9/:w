import scala.io.StdIn.readLine
import scala.collection.immutable.Set

object Day9 extends App {


    def read(line: String): List[(String, Int)] = line match {

        case "" => List()
        case _ => List((line.split(" ").head, line.split(" ").tail.head.toInt)) ++ read(readLine())
    }

    def unpack(commands: List[(String, Int)]): List[String] = commands match {
        
        case Nil => List()
        case h :: t => List.fill(h._2)(h._1) ++ unpack(t)
    }

    def move(chain: List[(Int, Int)], hx: Int, hy: Int)

    def sim(commands: List[String], positions: Set[(Int, Int)], 
                  hx: Int, hy: Int, tx: Int, ty: Int): Set[(Int, Int)] = {
                    //println(tx + "  " + ty + " ### " + hx + "  " + hy)
                    commands match {

        case Nil => positions
        case h :: t => h match {
            case "U" => if ((hy + 1 - ty).abs < 2 && (hx - tx).abs < 2) 
                          sim(t, positions, hx, hy + 1, tx, ty) 
                        else sim(t, positions ++ List((hx, hy)), hx, hy + 1, hx, hy)
            case "D" => if ((hy - 1 - ty).abs < 2 && (hx - tx).abs < 2)
                          sim(t, positions, hx, hy - 1, tx, ty)
                        else sim(t, positions ++ List((hx, hy)), hx, hy - 1, hx, hy)
            case "L" => if ((hy - ty).abs < 2 && (hx - 1 - tx).abs < 2) 
                          sim(t, positions, hx - 1, hy, tx, ty)
                        else sim(t, positions ++ List((hx, hy)), hx - 1, hy, hx, hy)
            case "R" => if ((hy - ty).abs < 2 && (hx + 1 - tx).abs < 2) 
                          sim(t, positions, hx + 1, hy, tx, ty)
                        else sim(t, positions ++ List((hx, hy)), hx + 1, hy, hx, hy)
        } 
                    }
    }

    val input = read(readLine())
    if (args.head == "--1") println(sim(unpack(input), Set((0, 0)), 0, 0, 0, 0).size)
}
